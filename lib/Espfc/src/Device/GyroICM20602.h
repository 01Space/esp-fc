#ifndef _ESPFC_DEVICE_GYRO_ICM20602_H_
#define _ESPFC_DEVICE_GYRO_ICM20602_H_

#include "BusDevice.h"
#include "GyroDevice.h"
#include "helper_3dmath.h"
#include "Debug_Espfc.h"

#define ICM20602_ADDRESS_FIRST       0x68 // address pin low (GND), default for InvenSense evaluation board
#define ICM20602_ADDRESS_SECOND      0x69 // address pin high (VCC)

#define ICM20602_RA_SMPLRT_DIV       0x19
#define ICM20602_RA_CONFIG           0x1A
#define ICM20602_RA_GYRO_CONFIG      0x1B
#define ICM20602_RA_ACCEL_CONFIG     0x1C
#define ICM20602_RA_ACCEL_XOUT_H     0x3B
#define ICM20602_RA_ACCEL_XOUT_L     0x3C
#define ICM20602_RA_ACCEL_YOUT_H     0x3D
#define ICM20602_RA_ACCEL_YOUT_L     0x3E
#define ICM20602_RA_ACCEL_ZOUT_H     0x3F
#define ICM20602_RA_ACCEL_ZOUT_L     0x40
#define ICM20602_RA_TEMP_OUT_H       0x41
#define ICM20602_RA_TEMP_OUT_L       0x42
#define ICM20602_RA_GYRO_XOUT_H      0x43
#define ICM20602_RA_GYRO_XOUT_L      0x44
#define ICM20602_RA_GYRO_YOUT_H      0x45
#define ICM20602_RA_GYRO_YOUT_L      0x46
#define ICM20602_RA_GYRO_ZOUT_H      0x47
#define ICM20602_RA_GYRO_ZOUT_L      0x48
#define ICM20602_RA_PWR_MGMT_1       0x6B
#define ICM20602_RA_PWR_MGMT_2       0x6C
#define ICM20602_RA_FIFO_COUNTH      0x72
#define ICM20602_RA_FIFO_COUNTL      0x73
#define ICM20602_RA_FIFO_R_W         0x74
#define ICM20602_RA_WHO_AM_I         0x75


#define ICM20602_PWR1_CLKSEL_BIT         2
#define ICM20602_PWR1_CLKSEL_LENGTH      3
#define ICM20602_PWR1_SLEEP_BIT          6

#define ICM20602_CLOCK_PLL_XGYRO         0x01

#define ICM20602_CFG_DLPF_CFG_BIT    2
#define ICM20602_CFG_DLPF_CFG_LENGTH 3

#define ICM20602_DLPF_BW_256         0x00
#define ICM20602_DLPF_BW_188         0x01
#define ICM20602_DLPF_BW_98          0x02
#define ICM20602_DLPF_BW_42          0x03
#define ICM20602_DLPF_BW_20          0x04
#define ICM20602_DLPF_BW_10          0x05
#define ICM20602_DLPF_BW_5           0x06

#define ICM20602_GCONFIG_FS_SEL_BIT      4
#define ICM20602_GCONFIG_FS_SEL_LENGTH   2

#define ICM20602_GYRO_FS_250         0x00
#define ICM20602_GYRO_FS_500         0x01
#define ICM20602_GYRO_FS_1000        0x02
#define ICM20602_GYRO_FS_2000        0x03

#define ICM20602_ACCEL_FS_2          0x00
#define ICM20602_ACCEL_FS_4          0x01
#define ICM20602_ACCEL_FS_8          0x02
#define ICM20602_ACCEL_FS_16         0x03

#define ICM20602_RESET               0x80

#define ICM20602_ACONFIG_AFS_SEL_BIT         4
#define ICM20602_ACONFIG_AFS_SEL_LENGTH      2

#define ICM20602_USERCTRL_FIFO_EN_BIT            6
#define ICM20602_USERCTRL_FIFO_RESET_BIT         2


namespace Espfc {

namespace Device {

class GyroICM20602: public GyroDevice
{
  public:
    int begin(BusDevice * bus) override
    {
      return begin(bus, ICM20602_ADDRESS_FIRST) ? 1 : begin(bus, ICM20602_ADDRESS_SECOND) ? 1 : 0;
    }

    int begin(BusDevice * bus, uint8_t addr) override
    {
      setBus(bus, addr);

      if(!testConnection()) return 0;

      // reset gyro
      _bus->writeByte(_addr, ICM20602_RA_PWR_MGMT_1, ICM20602_RESET);
      delay(100);

      // disable sleep mode and set clock source
      _bus->writeByte(_addr, ICM20602_RA_PWR_MGMT_1, ICM20602_CLOCK_PLL_XGYRO);
      delay(15);

      return 1;
    }

    GyroDeviceType getType() const override
    {
      return GYRO_ICM20602;
    }

    int readGyro(VectorInt16& v) override
    {
      uint8_t buffer[6];

      _bus->readFast(_addr, ICM20602_RA_GYRO_XOUT_H, 6, buffer);

      v.x = (((int16_t)buffer[0]) << 8) | buffer[1];
      v.y = (((int16_t)buffer[2]) << 8) | buffer[3];
      v.z = (((int16_t)buffer[4]) << 8) | buffer[5];

      return 1;
    }

    int readAccel(VectorInt16& v) override
    {
      uint8_t buffer[6];

      _bus->readFast(_addr, ICM20602_RA_ACCEL_XOUT_H, 6, buffer);

      v.x = (((int16_t)buffer[0]) << 8) | buffer[1];
      v.y = (((int16_t)buffer[2]) << 8) | buffer[3];
      v.z = (((int16_t)buffer[4]) << 8) | buffer[5];

      return 1;
    }

    void setDLPFMode(uint8_t mode) override
    {
      _dlpf = mode;
      _bus->writeBits(_addr, ICM20602_RA_CONFIG, ICM20602_CFG_DLPF_CFG_BIT, ICM20602_CFG_DLPF_CFG_LENGTH, mode);
    }

    int getRate() const override
    {
      switch(_dlpf)
      {
        case GYRO_DLPF_256:
        case GYRO_DLPF_EX:
          return 8000;
      }
      return 1000;
    }

    void setRate(int rate) override
    {
      // The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
      // Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
      // where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7),
      // and 1kHz when the DLPF is enabled (see Register 26).
      const uint8_t divider = (getRate() / rate) - 1;
      _bus->writeByte(_addr, ICM20602_RA_SMPLRT_DIV, divider);
    }

    void setFullScaleGyroRange(uint8_t range) override
    {
      _bus->writeBits(_addr, ICM20602_RA_GYRO_CONFIG, ICM20602_GCONFIG_FS_SEL_BIT, ICM20602_GCONFIG_FS_SEL_LENGTH, range);
    }

    void setFullScaleAccelRange(uint8_t range) override
    {
      _bus->writeBits(_addr, ICM20602_RA_ACCEL_CONFIG, ICM20602_ACONFIG_AFS_SEL_BIT, ICM20602_ACONFIG_AFS_SEL_LENGTH, range);
    }

    bool testConnection() override
    {
      uint8_t whoami = 0;
      _bus->readByte(_addr, ICM20602_RA_WHO_AM_I, &whoami);
      //D("icm20602:whoami", _addr, whoami);
      return whoami == 0x12;
    }

    uint8_t _dlpf;
};

}

}

#endif
